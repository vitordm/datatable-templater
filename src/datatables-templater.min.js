/**
 * Plugin DataTable Templater
 * @author Vítor Oliveira <oliveira.vitor3@gmail.com>
 */
!function () { function getObjectPropertyOrDefault(e, t, a, l) { let o = e.hasOwnProperty(t) ? e[t] : a; return l && typeof o != l && "boolean" == l && (o = "true" === o), o } function parseStringMatchValue(str, data) { let matches = str.match(/\{\$.*?\}/gi); return !matches || matches.length <= 0 ? str : (matches.forEach(element => { let evalValue = element.replace(/^\{\$|\}/gi, ""); try { eval(`evalValue = data['${evalValue}']`) } catch (e) { evalValue = "" } evalValue || (evalValue = ""), str = str.replace(element, evalValue) }), str) } function parseActionsDataTableItem(item, actions) { let htmlResult = ""; for (const action of actions) { const { href: href, type: type, onclick: onclick, label: label, condition: condition } = action; let classAction = action.class; if (condition) { let conditionPassed = eval(parseStringMatchValue(condition, item)); if (!conditionPassed) continue } let htmlTagActionAttributes = "", isButton = !1, labelHtml = ""; switch (type) { case "EDIT": labelHtml = window.DataTableTemplaterConfigs.editLabel, classAction || (classAction = window.DataTableTemplaterConfigs.editClass); break; case "DELETE": labelHtml = window.DataTableTemplaterConfigs.deleteLabel, classAction || (classAction = window.DataTableTemplaterConfigs.deleteClass); break; case "VIEW": labelHtml = window.DataTableTemplaterConfigs.viewLabel, classAction || (classAction = window.DataTableTemplaterConfigs.viewClass); break; default: labelHtml = label }href ? htmlTagActionAttributes = `${htmlTagActionAttributes} href="${parseStringMatchValue(href, item)}"` : isButton = !0, onclick && (htmlTagActionAttributes = `${htmlTagActionAttributes} onclick="${parseStringMatchValue(onclick, item)}"`), classAction && (htmlTagActionAttributes = `${htmlTagActionAttributes} class="${classAction}"`), htmlResult += isButton ? `<button ${htmlTagActionAttributes}>${labelHtml}</button>` : `<a ${htmlTagActionAttributes}>${labelHtml}</a>` } return htmlResult } function factoryDataTableFromHtml(idTableHtml, options = {}) { idTableHtml.match(/^\^/) || (idTableHtml = `#${idTableHtml}`), options.hasOwnProperty("actions") && Array.isArray(options.actions) || (options.actions = []); const tableJQuery = $(idTableHtml), thsCollections = document.querySelector(`${idTableHtml} > thead > tr`).children, dataAttributes = ["data-item-type", "data-item-class", "data-item-iskey", "data-item-bind", "data-column-name", "data-column-visible", "data-column-searchable", "data-item-text", "data-column-orderable", "data-column-ordernable"], typesAndClassesFields = { date: "td-dates", datetime: "td-dates", icon: "td-icons", int: "td-numbers ", float: "td-numbers ", double: "td-numbers ", number: "td-numbers ", money: "td-numbers ", string: "td-text", "string-center": "td-text-center", "string-right": "td-text-right" }; let hasKey = !1, keyColumn = "id", columnDefs = [], columns = [], indexColumns = -1, hasActions = !1; const columnsBinds = {}; for (const e of thsCollections) { const t = Object.keys(e.attributes), a = t.reduce((t, a, l, o) => { const n = e.attributes[a]; return dataAttributes.includes(n.name) ? (t[n.name] = n.value, t) : t }, {}); if (Object.keys(a) <= 0) continue; const l = getObjectPropertyOrDefault(a, "data-item-type", "__custom"), o = getObjectPropertyOrDefault(typesAndClassesFields, l, ""), n = getObjectPropertyOrDefault(a, "data-column-visible", !0, "boolean"); if ("actions" == l) { hasActions = !0, columns.push({ data: "__actions", visible: n, searchable: !1 }), indexColumns++, columnDefs.push({ className: "td-icons", orderable: !1, targets: [indexColumns] }); continue } let s = getObjectPropertyOrDefault(a, "data-column-orderable", !1, "boolean"); s || (s = getObjectPropertyOrDefault(a, "data-column-ordernable", !1, "boolean")); const i = getObjectPropertyOrDefault(a, "data-column-searchable", !1, "boolean"), r = getObjectPropertyOrDefault(a, "data-item-bind", ""), c = getObjectPropertyOrDefault(a, "data-item-class", ""), d = getObjectPropertyOrDefault(a, "data-column-name", null); columns.push({ data: r, visible: n, searchable: i, name: d }), indexColumns++, columnDefs.push({ className: `${o} ${c}`.trim(), ordernable: s, targets: [indexColumns] }); const m = getObjectPropertyOrDefault(a, "data-item-iskey", !1, "boolean"); m && !hasKey && (keyColumn = r, hasKey = !0); const u = getObjectPropertyOrDefault(a, "data-item-text"); columnsBinds[r] = { classItemType: o, classDefined: c, itemType: l, visible: n, itemIsKey: m, itemText: u } } const url = tableJQuery.attr("data-table-url"), ajax = { method: "POST", url: url }; options.hasOwnProperty("data") && (ajax.data = options.data), options.hasOwnProperty("beforeSend") && (ajax.beforeSend = options.beforeSend); const optionsDatatable = { serverSide: !0, columns: columns, columnDefs: columnDefs, ajax: ajax }; let callbackDataSrc; callbackDataSrc = options.hasOwnProperty("callback") ? options.callback : json => { const result = []; for (const data of json.data) { let item = {}; for (const bindKey of Object.keys(columnsBinds)) { const optionsItem = columnsBinds[bindKey]; let value = ""; if (optionsItem.itemText) try { value = optionsItem.itemText; let matchesReplaces = optionsItem.itemText.match(/\{\$.*?\}/gi); matchesReplaces && matchesReplaces.length && matchesReplaces.forEach(element => { let evalValue = element.replace(/^\{\$|\}/gi, ""); eval(`evalValue = ${evalValue}`), evalValue = window.utils.valueStringNullToEmptyString(evalValue), value = value.replace(element, evalValue) }) } catch (e) { } else switch (value = data[bindKey], optionsItem.itemType) { case "date": value = window.utils.jsonDateStringToFormat(value); break; case "datetime": value = window.utils.jsonDateTimeStringToFormat(value); break; case "money": value = window.utils.numberToMoney(value) }item[bindKey] = value } result.push(item) } return result }; let checkUrl = tableJQuery.attr("data-url-view"); return checkUrl && options.actions.push({ href: checkUrl, type: "VIEW" }), checkUrl = tableJQuery.attr("data-url-edit"), checkUrl && options.actions.push({ href: checkUrl, type: "EDIT" }), checkUrl = tableJQuery.attr("data-url-delete"), checkUrl && options.actions.push({ onclick: `__dataTableTemplaterConfirm('${checkUrl}')`, type: "DELETE" }), ajax.dataSrc = (e => { optionsDatatable.dados = e.data; let t = callbackDataSrc(e); return hasActions && (t = t.map(e => { if (hasKey && (e.key = e[keyColumn]), !e.hasOwnProperty("__actions")) { let t = parseActionsDataTableItem(e, options.actions); window.DataTableTemplaterConfigs.actionDivGroup ? e.__actions = `<div class="btn-group" role="group">${t}</div>` : e.__actions = t } return e })), t }), optionsDatatable.lengthMenu = [[10, 25, 50, 100], [10, 25, 50, 100]], optionsDatatable.language = window.DataTableTemplaterConfigs.language, optionsDatatable.processing = !0, tableJQuery.DataTable(optionsDatatable) } const utils = { jsonDateStringToFormat: function (e) { return e ? moment(e).format("DD/MM/YYYY") : e }, jsonDateTimeStringToFormat: function (e) { return e ? moment(e).format("DD/MM/YYYY HH:mm:ss") : e }, numberToMoney: e => null == e ? e : e.toLocaleString("pt-BR", { minimumFractionDigits: 2 }), valueStringNullToEmptyString: e => "string" == typeof e && !e || null == e ? "" : e }; window.utils = utils, window.window.DataTableTemplaterConfigs || (window.DataTableTemplaterConfigs = { globalConfirm: null }), window.DataTableTemplaterConfigs.language || (window.DataTableTemplaterConfigs.language = { sEmptyTable: "Nenhum registro encontrado", sInfo: "Mostrando de _START_ até _END_ de _TOTAL_ registros", sInfoEmpty: "Mostrando 0 até 0 de 0 registros", sInfoFiltered: "(Filtrados de _MAX_ registros)", sInfoPostFix: "", sInfoThousands: ".", sLengthMenu: "_MENU_ resultados por página", sLoadingRecords: "Carregando...", sProcessing: "Processando...", sZeroRecords: "Nenhum registro encontrado", sSearch: "Pesquisar", oPaginate: { sNext: "Próximo", sPrevious: "Anterior", sFirst: "Primeiro", sLast: "Último" }, oAria: { sSortAscending: ": Ordenar colunas de forma ascendente", sSortDescending: ": Ordenar colunas de forma descendente" }, select: { rows: { _: "Selecionado %d linhas", 0: "Nenhuma linha selecionada", 1: "Selecionado 1 linha" } }, buttons: { copy: "Copiar para a área de transferência", copyTitle: "Cópia bem sucedida", copySuccess: { 1: "Uma linha copiada com sucesso", _: "%d linhas copiadas com sucesso" } } }), void 0 === window.DataTableTemplaterConfigs.actionDivGroup && (window.DataTableTemplaterConfigs.actionDivGroup = !0), window.DataTableTemplaterConfigs.editLabel || (window.DataTableTemplaterConfigs.editLabel = "Editar"), window.DataTableTemplaterConfigs.editClass || (window.DataTableTemplaterConfigs.editClass = "btn btn-secondary"), window.DataTableTemplaterConfigs.deleteLabel || (window.DataTableTemplaterConfigs.deleteLabel = "Deletar"), window.DataTableTemplaterConfigs.deleteClass || (window.DataTableTemplaterConfigs.deleteClass = "btn btn-danger"), window.DataTableTemplaterConfigs.viewLabel || (window.DataTableTemplaterConfigs.viewLabel = "Visualizar"), window.DataTableTemplaterConfigs.viewClass || (window.DataTableTemplaterConfigs.viewClass = "btn btn-info"), window.__dataTableTemplaterConfirm = (e => { window.DataTableTemplaterConfigs.globalConfirm ? window.DataTableTemplaterConfigs.globalConfirm(e) : window.location = e }), window.atualizarDataTable = function (e) { e && e.ajax.reload() }, window.factoryDataTableFromHtml = factoryDataTableFromHtml.bind(this) }();